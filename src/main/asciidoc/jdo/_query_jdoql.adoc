[[jdoql]]
= JDOQL
:_basedir: ../
:_imagesdir: images/


JDO provides its own object-based query language (JDOQL), designed to have the power of SQL queries, yet retaining the Java object relationship 
that exist in the developers application model. 

A JDOQL query may be created in several ways. Here's an example expressed in the 3 supported ways

[source,java]
-----
// String-based JDOQL :
Query q = pm.newQuery("SELECT FROM mydomain.Person WHERE lastName == 'Jones' && age < age_limit PARAMETERS int age_limit");
List<Person> results = (List<Person>)q.execute(20);

// Declarative JDOQL :
Query q = pm.newQuery(Person.class);
q.setFilter("lastName == 'Jones' && age < age_limit");
q.declareParameters("int age_limit");
List<Person> results = q.setParameters(20).executeList();

// Typed JDOQL :
JDOQLTypedQuery<Person> tq = pm.newJDOQLTypedQuery(Person.class);
QPerson cand = QPerson.candidate();
List<Person> results = 
    tq.filter(cand.lastName.eq("Jones").and(cand.age.lt(tq.intParameter("age_limit"))))
        .setParameter("age_limit", "20").executeList();
-----

So here in our example we select all "Person" objects with surname of "Jones" and where the persons age is below 20. 
The language is intuitive for Java developers, and is intended as their interface to accessing the persisted data model. 
As can be seen above, the query is made up of distinct parts: the class being processed (equates to the FROM clause in SQL), the data being selected (the SELECT clause in SQL), 
the filter (the WHERE clause in SQL), together with any sorting (the ORDER BY clause in SQL), etc.

We will cover the _string-based_ and _declarative_ modes of JDOQL API in this chapter, and the _Typed JDOQL_ is covered in link:query.html#jdoql_typed[its own chapter].


NOTE: When using RDBMS all parts of a query are evaluated *in-datastore*.
When using LDAP, Excel, ODF, XML, JSON, GoogleStorage, AmazonS3 any query filter/ordering etc is evaluated *in-memory*.
When using Neo4j, HBase, MongoDB and Cassandra any query filter/ordering etc are evaluated *in-datastore* where possible, with the remainder evaluated *in-memory*.




[[jdoql_string]]
== JDOQL Single-String syntax

JDOQL queries can be defined in a single-string form, as follows

-----
SELECT [UNIQUE] [<result>] [INTO <result-class>]
        [FROM <candidate-class> [EXCLUDE SUBCLASSES]]
        [WHERE <filter>]
        [VARIABLES <variable declarations>]
        [PARAMETERS <parameter declarations>]
        [<import declarations>]
        [GROUP BY <grouping>]
        [ORDER BY <ordering>]
        [RANGE <start>, <end>]
-----

The "keywords" in the query are shown in UPPER CASE but can be in _UPPER_ or _lower_ case (but not MiXeD case). So giving an example

-----
SELECT UNIQUE FROM mydomain.Employee ORDER BY departmentNumber
-----


[[jdoql_candidate]]
== Candidate Class

By default the candidate "class" with JDOQL has to be a persistable class. 
This can then be referred to in the query using the _this_ keyword (just like in Java). 
Also by default your query will return instances of subclasses of the candidate class. 
You can restrict to just instances of the candidate by specifying to exclude subclasses 
(see EXCLUDE SUBCLASSES in the string-based syntax, or by _setSubclasses(false)_ when using the declarative API).

NOTE: The "candidate" has an implicit "alias" in JDOQL, which is _this_ (just like in Java). So in the rest of the query you can refer to a field of the candidate as _this.{fieldName}_

NOTE: If the candidate has a table using a discriminator, the generated SQL for RDBMS will include a restriction of the possible discriminator values to the candidate and any applicable
subclasses. If you want to override this and NOT have a discriminator restriction imposed in the SQL then you provide the query extension *datanucleus.query.dontRestrictDiscriminator* set to _true_.


=== Candidate Persistent Interface
image:../images/nucleus_extension.png[]

DataNucleus also allows you to specify a candidate class as persistent interface. 
This is used where we want to query for instances of implementations of the interface. 
Let's take an example. We have an interface, and some implementations

[source,java]
-----
@PersistenceCapable
public interface ComputerPeripheral
{
    @PrimaryKey
    long getId();
    void setId(long val);

    @Persistent
    String getManufacturer();
    void setManufacturer(String name);

    @Persistent
    String getModel();
    void setModel(String name);
}

@PersistenceCapable
public class Mouse implements ComputerPeripheral {...}

@PersistenceCapable
public class Keyboard implements ComputerPeripheral {...}
-----

So we have made our interface persistable, and defined the identity property(ies) there. 
The implementations of the interface will use the identity defined in the interface. To query it we simply do

[source,java]
-----
Query q = pm.newQuery(ComputerPeripheral.class);
List<ComputerPeripheral> results = q.executeList();
-----

The key rules are

* You must define the interface as persistent
* The interface must define the identity/primary key member(s)
* The implementations must have the same definition of identity and primary key



[[jdoql_filter]]
== Filter

The most important thing to remember when defining the _filter_ for JDOQL is that *think how you would write it in Java, and its likely the same*. 
The _filter_ has to be a boolean expression, and can include 
link:#jdoql_candidate[the candidate], link:#jdoql_fields_properties[fields/properties], link:#jdoql_literals[literals], 
link:#jdoql_methods[methods], link:#jdoql_parameters[parameters], link:#jdoql_variables[variables],
link:#jdoql_operators[operators], link:#jdoql_instanceof[instanceof], link:#jdoql_subqueries[subqueries] and link:#jdoql_casts[casts].



With the Declarative API you would define the filter using the _Query.filter_ method, like this
[source,java]
-----
q.filter("this.inventory.name == 'MyInventory'");
-----


[[jdoql_fields_properties]]
== Fields/Properties

In JDOQL you refer to fields/properties in the query by referring to the field/bean name. 
For example, if you are querying a candidate class called _Product_ and it has a field "price", then you access it like this

[source,java]
-----
price < 150.0
-----

Note that, just like in Java, if you want to refer to a field/property of the candidate you can prefix the field by its implicit alias _this_

[source,java]
-----
this.price < 150.0
-----

You can also chain field references, so if you have a candidate class Product with a field of (persistable) type Inventory, which has a field _name_, then you could do

[source,java]
-----
this.inventory.name == 'Backup'
-----

In addition to the persistent fields, you can also access "public static final" fields of any class. You can do this as follows

[source,java]
-----
taxPercent < mydomain.Product.TAX_BAND_A
-----

So this will find all products that include a tax percentage less than some "BAND A" level.
Where you are using "public static final" fields you can either fully-qualify the class name or you can include it in the "imports" section of the query (see later).

NOTE: With JDOQL you do not do _explicit_ joins. You instead use the fields/properties and navigate to the object you want to make use of in your query

With 1-1/N-1 relations this is simply a reference to the field/property, and place some restriction on it, like this

[source,java]
-----
this.inventory.name == 'MyInventory'
-----

With 1-N/M-N relations you would introduce a link:#jdoql_variables[JDOQL variable] and use something like

[source,java]
-----
containerField.contains(elemVar)
-----

and thereafter refer to _elemVar_ for the element in the collection to place restrictions on the element. Similarly you can use _elemVar_ in the result clause

image:../images/nucleus_extension.png[]

*RDBMS* : By default when you navigate through a 1-1/N-1 relation in JDOQL DataNucleus will decide to join using either LEFT OUTER JOIN or INNER JOIN
based on whether the relation is _nullable_. If it is nullable then LEFT OUTER JOIN will be used. 
You can change this default by specifying the persistence property (to apply to all queries) or query extension *datanucleus.query.jdoql.navigationJoinType* 
and set it to either "INNERJOIN" or "LEFTOUTERJOIN". 
You can also set the default for the _filter_ only using the persistence property(to apply to all queries) or query extension 
*datanucleus.query.jdoql.navigationJoinTypeForFilter* and set it to either "INNERJOIN" or "LEFTOUTERJOIN". 



[[jdoql_methods]]
== Methods

When writing the "filter" for a JDOQL Query you can make use of some methods on the various Java types. 
The range of methods included as standard in JDOQL is not as flexible as with the true Java types, but the ones that are available are typically of much use.
While DataNucleus supports all of the methods in the JDO standard, it also supports several yet to be standardised (extension) method. 
The tables below also mark whether a particular method is supported for evaluation link:#jdoql_inmemory[in-memory].

NOTE: These methods are not available for use with all of the supported datastores to be executed in-datastore. 
RDBMS, in general, supports the vast majority, whilst MongoDB, Neo4j, Cassandra support a select few methods in-datastore.

NOTE: You can add "in-memory" evaluation support for other methods using this 
image:../images/nucleus_extensionpoint.png[link=../extensions/extensions.html#query_method_evaluators]

NOTE: You can add "RDBMS datastore" support for other methods using this 
image:../images/nucleus_extensionpoint.png[link=../extensions/extensions.html#rdbms_sql_method]


[[jdoql_methods_string]]
=== String Methods

[cols="3,8,1,1", options="header"]
|===
|Method
|Description
|Standard
|In-Memory

|startsWith(String)
|Returns if the string starts with the passed string
|icon:check[]
|icon:check[]

|startsWith(String, int)
|Returns if the string starts with the passed string, from the passed position
|icon:check[]
|icon:check[]

|endsWith(String)
|Returns if the string ends with the passed string
|icon:check[]
|icon:check[]

|indexOf(String)
|Returns the first position of the passed string
|icon:check[]
|icon:check[]

|indexOf(String,int)
|Returns the position of the passed string, after the passed position
|icon:check[]
|icon:check[]

|substring(int)
|Returns the substring starting from the passed position
|icon:check[]
|icon:check[]

|substring(int,int)
|Returns the substring between the passed positions
|icon:check[]
|icon:check[]

|toLowerCase()
|Returns the string in lowercase
|icon:check[]
|icon:check[]

|toUpperCase()
|Retuns the string in UPPERCASE
|icon:check[]
|icon:check[]

|matches(String pattern)
|Returns whether string matches the passed expression. The pattern argument follows the rules of java.lang.String.matches method.
Only the following regular expression patterns are required to be supported and are portable: global “(?i)” for case-insensitive matches; and “.”
and “.*” for wild card matches. The pattern passed to matches must be a literal or parameter.
|icon:check[]
|icon:check[]

|charAt(int)
|Returns the character at the passed position
|icon:check[]
|icon:check[]

|length()
|Returns the length of the string
|icon:check[]
|icon:check[]

|trim()
|Returns a trimmed version of the string
|icon:check[]
|icon:check[]

|concat(String)
|Concatenates the current string and the passed string
|icon:times[]
|icon:check[]

|equals(String)
|Returns if the strings are equal
|icon:times[]
|icon:check[]

|equalsIgnoreCase(String)
|Returns if the strings are equal ignoring case
|icon:times[]
|icon:check[]

|replaceAll(String, String)
|Returns the string with all instances of _str1_ replaced by _str2_
|icon:times[]
|icon:times[]

|trimLeft()
|Returns a trimmed version of the string (trimmed for leading spaces). *Only on RDBMS, Neo4j*
|icon:times[]
|icon:check[]

|trimRight()
|Returns a trimmed version of the string (trimmed for trailing spaces). *Only on RDBMS, Neo4j*
|icon:times[]
|icon:check[]
|===

Here's an example using a Product class, looking for objects which their abbreviation is the beginning of a trade name. 
The trade name is provided as parameter.

[source,java]
-----
Declarative JDOQL :
Query query = pm.newQuery(Product.class);
query.setFilter(":tradeName.startsWith(this.abbreviation)");
List<Product> results = query.setParameters("Workbook Advanced").executeList();

Single-String JDOQL :
Query query = pm.newQuery("SELECT FROM mydomain.Product WHERE :tradeName.startsWith(this.abbreviation)");
List results = (List)query.execute("Workbook Advanced");
-----


[[jdoql_methods_collection]]
=== Collection Methods

[cols="3,8,1,1", options="header"]
|===
|Method
|Description
|Standard
|In-Memory

|isEmpty()
|Returns whether the collection is empty
|icon:check[]
|icon:check[]

|contains(value)
|Returns whether the collection contains the passed element
|icon:check[]
|icon:check[]

|size()
|Returns the number of elements in the collection
|icon:check[]
|icon:check[]

|get(int)
|Returns the element at that position of the List
|icon:check[]
|icon:check[]

|indexOf(elem)
|Returns the position in the List of the element.
|icon:times[]
|icon:check[]
|===

Here's an example demonstrating use of contains(). 
We have an Inventory class that has a Collection of Product objects, and we want to find the Inventory objects with 2 particular Products in it. 
Here we make use of a variable (_prd_ to represent the Product being contained

[source,java]
-----
Declarative JDOQL :
Query query = pm.newQuery(Inventory.class);
query.setFilter("products.contains(prd) && (prd.name=='product 1' || prd.name=='product 2')");
List<Inventory> results = query.executeList();

Single-String JDOQL:
Query query = pm.newQuery("SELECT FROM mydomain.Inventory " + 
    "WHERE products.contains(prd) && (prd.name=='product 1' || prd.name=='product 2')");
List results = (List)query.execute();
-----

[[jdoql_methods_map]]
=== Map Methods

[cols="3,8,1,1", options="header"]
|===
|Method
|Description
|Standard
|In-Memory

|isEmpty()
|Returns whether the map is empty
|icon:check[]
|icon:check[]

|containsKey(key)
|Returns whether the map contains the passed key
|icon:check[]
|icon:check[]

|containsValue(value)
|Returns whether the map contains the passed value
|icon:check[]
|icon:check[]

|get(key)
|Returns the value from the map with the passed key
|icon:check[]
|icon:check[]

|size()
|Returns the number of entries in the map
|icon:check[]
|icon:check[]

|containsEntry(key, value)
|Returns whether the map contains the passed entry
|icon:times[]
|icon:times[]
|===

Here's an example using a Product class as a value in a Map. 
Our example represents an organisation that has several Inventories of products. Each Inventory of products is stored using a Map, keyed by the Product name. 
The query searches for all Inventories that contain a product with the name "product 1".

[source,java]
-----
Declarative JDOQL :
Query query = pm.newQuery(mydomain.Inventory.class, "products.containsKey('product 1')");
List<Inventory> results = query.execute();

Single-String JDOQL :
Query query = pm.newQuery("SELECT FROM mydomain.Inventory WHERE products.containsKey('product 1')");
List results = (List)query.execute();
-----

Here's the source code for reference

[source,java]
-----
class Inventory
{
    Map<String, Product> products;
    ...
}
class Product
{
    ...
}
-----
 

[[jdoql_methods_temporal]]
=== java.util.Date Temporal Methods

[cols="3,8,1,1", options="header"]
|===
|Method
|Description
|Standard
|In-Memory

|getDate()
|Returns the day (of the month) for the date (java.util.Date types) in the timezone it was stored
|icon:check[]
|icon:check[]

|getMonth()
|Returns the month for the date (java.util.Date types) (0-11) in the timezone it was stored
|icon:check[]
|icon:check[]

|getYear()
|Returns the year for the date (java.util.Date types) in the timezone it was stored
|icon:check[]
|icon:check[]

|getHour()
|Returns the hour for the time (java.util.Date types) in the timezone it was stored
|icon:check[]
|icon:check[]

|getMinute()
|Returns the minute for the time (java.util.Date types) in the timezone it was stored
|icon:check[]
|icon:check[]

|getSecond()
|Returns the second for the time (java.util.Date types) in the timezone it was stored
|icon:check[]
|icon:check[]

|getDayOfWeek()
|Returns the day of the week for the date (java.util.Date types) (1-7) in the timezone it was stored
|icon:check[]
|icon:check[]
|===


[[jdoql_methods_javatime]]
=== java.time Temporal Methods

[cols="3,3,8,1,1", options="header"]
|===
|Class
|Method
|Description
|Standard
|In-Memory

|LocalDate
|getDayOfMonth()
|Returns the day (of the month) for the date (1-31) in the timezone it was stored
|icon:check[]
|icon:check[]

|LocalDate
|getDayOfWeek()
|Returns the day of the week for the date (1-7) in the timezone it was stored
|icon:check[]
|icon:check[]

|LocalDate
|getMonthValue()
|Returns the month for the date (1-12) in the timezone it was stored
|icon:check[]
|icon:check[]

|LocalDate
|getYear()
|Returns the year for the date in the timezone it was stored
|icon:check[]
|icon:check[]

|LocalDateTime
|getDayOfMonth()
|Returns the day (of the month) for the date in the timezone it was stored
|icon:check[]
|icon:check[]

|LocalDateTime
|getDayOfWeek()
|Returns the day of the week for the date (1-7) in the timezone it was stored
|icon:check[]
|icon:check[]

|LocalDateTime
|getMonthValue()
|Returns the month for the date (1-12) in the timezone it was stored
|icon:check[]
|icon:check[]

|LocalDateTime
|getYear()
|Returns the year for the date in the timezone it was stored
|icon:check[]
|icon:check[]

|LocalDateTime
|getHour()
|Returns the hour for the time in the timezone it was stored
|icon:check[]
|icon:check[]

|LocalDateTime
|getMinute()
|Returns the minute for the time in the timezone it was stored
|icon:check[]
|icon:check[]

|LocalDateTime
|getSecond()
|Returns the second for the time in the timezone it was stored
|icon:check[]
|icon:check[]

|LocalTime
|getHour()
|Returns the hour for the time in the timezone it was stored
|icon:check[]
|icon:check[]

|LocalTime
|getMinute()
|Returns the minute for the time in the timezone it was stored
|icon:check[]
|icon:check[]

|LocalTime
|getSecond()
|Returns the second for the time in the timezone it was stored
|icon:check[]
|icon:check[]

|MonthDay
|getMonthValue()
|Returns the month (1-12)
|icon:check[]
|icon:check[]

|MonthDay
|getDayOfMonth()
|Returns the day of the month (1-31)
|icon:check[]
|icon:check[]

|Period
|getDays()
|Returns the number of days
|icon:check[]
|icon:check[]

|Period
|getMonths()
|Returns the number of months
|icon:check[]
|icon:check[]

|Period
|getYears()
|Returns the number of years
|icon:check[]
|icon:check[]

|YearMonth
|getMonthValue()
|Returns the month
|icon:check[]
|icon:check[]

|YearMonth
|getYear()
|Returns the year
|icon:check[]
|icon:check[]
|===


[[jdoql_methods_jodatime]]
=== Jodatime Temporal Methods

[cols="3,3,8,1,1", options="header"]
|===
|Class
|Method
|Description
|Standard
|In-Memory

|Interval
|getStart()
|Returns the start of an Interval
|icon:times[]
|icon:check[]

|Interval
|getEnd()
|Returns the end of an Interval
|icon:times[]
|icon:check[]
|===


[[jdoql_methods_enum]]
=== Enum Methods

[cols="3,8,1,1", options="header"]
|===
|Method
|Description
|Standard
|In-Memory

|ordinal()
|Returns the ordinal of the enum (not implemented for enum expression when persisted as a string)
|icon:check[]
|icon:check[]

|toString()
|Returns the string form of the enum (not implemented for enum expression when persisted as a numeric)
|icon:check[]
|icon:check[]
|===


[[jdoql_methods_other]]
=== Other Methods

[cols="3,3,8,1,1", options="header"]
|===
|Class
|Method
|Description
|Standard
|In-Memory

|{}
|length
|Returns the length of an array. *Only on RDBMS*
|icon:times[]
|icon:times[]

|{}
|contains(object)
|Returns true if the array contains the object. *Only on RDBMS*
|icon:times[]
|icon:times[]

|java.util.Optional
|isPresent()
|Returns whether the value is present in this optional.
|icon:check[]
|icon:check[]

|java.util.Optional
|get()
|Returns the delegated object
|icon:check[]
|icon:check[]

|java.util.Optional
|orElse(object)
|Returns the value of the optional if present, otherwise the supplied object.
|icon:check[]
|icon:check[]
|===


[[jdoql_methods_static]]
=== Static Methods

[cols="3,8,1,1", options="header"]
|===
|Method
|Description
|Standard
|In-Memory

|Math.abs(number)
|Returns the absolute value of the passed number
|icon:check[]
|icon:check[]

|Math.sqrt(number)
|Returns the square root of the passed number
|icon:check[]
|icon:check[]

|Math.cos(number)
|Returns the cosine of the passed number
|icon:check[]
|icon:check[]

|Math.sin(number)
|Returns the absolute value of the passed number
|icon:check[]
|icon:check[]

|Math.tan(number)
|Returns the tangent of the passed number
|icon:check[]
|icon:check[]

|Math.acos(number)
|Returns the arc cosine of the passed number
|icon:check[]
|icon:check[]

|Math.asin(number)
|Returns the arc sine of the passed number
|icon:check[]
|icon:check[]

|Math.atan(number)
|Returns the arc tangent of the passed number
|icon:check[]
|icon:check[]

|Math.ceil(number)
|Returns the ceiling of the passed number
|icon:check[]
|icon:check[]

|Math.exp(number)
|Returns the exponent of the passed number
|icon:check[]
|icon:check[]

|Math.floor(number)
|Returns the floor of the passed number
|icon:check[]
|icon:check[]

|Math.log(number)
|Returns the log(base e) of the passed number
|icon:check[]
|icon:check[]

|Math.round(number)
|Returns the rounded value of the passed number
|icon:times[]
|icon:times[]

|Math.toDegrees(number)
|Returns the degrees of the passed radians value
|icon:times[]
|icon:check[]

|Math.toRadians(number)
|Returns the radians of the passed degrees value
|icon:times[]
|icon:check[]

|Math.power(number, power)
|Returns the passed number to the specified power
|icon:times[]
|icon:times[]

|JDOHelper.getObjectId(object)
|Returns the object identity of the passed persistent object
|icon:check[]
|icon:check[]

|JDOHelper.getVersion(object)
|Returns the version of the passed persistent object
|icon:check[]
|icon:check[]

|SQL_rollup({object})
|Perform a rollup operation over the results. *Only for some RDBMS e.g DB2, MSSQL, Oracle*
|icon:times[]
|icon:times[]

|SQL_cube({object})
|Perform a cube operation over the results. *Only for some RDBMS e.g DB2, MSSQL, Oracle*
|icon:times[]
|icon:times[]

|SQL_boolean({sql})
|Embed the provided SQL and return a boolean result. *Only on RDBMS*
|icon:times[]
|icon:times[]

|SQL_numeric({sql})
|Embed the provided SQL and return a numeric result. *Only on RDBMS*
|icon:times[]
|icon:times[]
|===


include::_query_jdoql_geospatial_methods.adoc[leveloffset=+2]




[[jdoql_literals]]
== Literals

JDOQL supports literals of the following types : Number, boolean, character, String, and _null_. 
For example, with a numeric literal

[source,java]
-----
Query q = pm.newQuery("SELECT FROM mydomain.Person WHERE age == 25");
-----

When String literals are specified using string format JDOQL they should be surrounded by single-quotes _'_. For example

[source,java]
-----
Query q = pm.newQuery("SELECT FROM mydomain.Person WHERE firstName == 'John'");
-----


image:../images/nucleus_extension.png[]

DataNucleus also provides an extension to support array literals for RDBMS. You would do as follows in your JDOQL

[source,java]
-----
Query q = pm.newQuery("SELECT FROM mydomain.Person WHERE {'John', 'Fred', 'Graham'}.contains(firstName)");
-----

namely using curly brackets to represent the array with its literal elements.



=== RDBMS : Parameters .v. Literals

When considering whether to embody a literal into a JDOQL query, you should consider using a parameter instead. 
The advantage of using a parameter is that the generated SQL will have a '?' rather than the value. As a result, if you are using a connection pool
that supports PreparedStatement caching, this will potentially reuse an existing statement rather than generating a new one each time.
If you only ever invoke a query with a single possible value of the parameter then there is no advantage.
If you invoke the query with multiple possible values of the parameter then this advantage can be significant.




[[jdoql_parameters]]
== Parameters

With a query you can pass values into the query as parameters. 
This is useful where you don't want to embed particular values in the query itself, so making it reusable with different values.
JDOQL allows two types of parameters.


=== Explicit Parameters

If you _declare_ the parameters when defining the query (using the PARAMETERS keyword in the single-string form, or via the declareParameters method) then these are *explicit* parameters. 
This sets the type of the parameter, and when you pass the value in at _execute_ it has to be of that type. For example

[source,java]
-----
Query query = pm.newQuery("SELECT FROM mydomain.Product WHERE price < limit PARAMETERS double limit");
List results = (List)query.execute(150.00);
-----

Note that if declaring multiple parameters then they should be comma-separated.

With the Declarative API you would define explicit parameters like this (and use comma-separated if defining multiple)

[source,java]
-----
q.parameters("double limit");
-----


=== Implicit Parameters

If you don't declare the parameters when defining the query but instead prefix identifiers in the query with *:* (colon) then these are *implicit* parameters. 
For example

[source,java]
-----
Query query = pm.newQuery("SELECT FROM mydomain.Product WHERE price < :limit");
List results = (List)query.execute(150.00);
-----

image:../images/nucleus_extension.png[]

In some situations you may have a map of parameters keyed by their name, yet the query in question doesn't need all parameters. 
Normal JDO execution would throw an exception here since they are inconsistent with the query. You can omit this check by setting

[source,java]
-----
q.addExtension("datanucleus.query.checkUnusedParameters", "false");
-----

=== Setting parameters at execution time

Defining a query to accept parameters is only the first part. You then need to specify the parameter values at execution time. This can be done
in many ways, but here are some examples

[source,java]
-----
// === JDOQL with named parameters ===
...
q.setFilter("this.name == :name && this.serialNo == :serial");

Map params = new HashMap();
params.put("name", "Walkman");
params.put("serial", "123021");


// Set parameter values via method call
q.setNamedParameters(params);


// Alternatively set the parameter values on execute()
q.executeWithMap(params);



// === JDOQL with numbered parameters ===
...
q.setFilter("this.name == ?1 && this.serialNo == ?2");

// Set parameter values via method call, using the number order of the query parameters
q.setParameters("Walkman", "123021");


// Alternatively set the parameter values on execute(), using the number order of the query parameters
q.execute("Walkman", "123021");

-----



[[jdoql_variables]]
== Variables

In JDOQL you can connect two parts of a query using something known as a variable. 
For example, we want to retrieve all objects with a collection that contains a particular element, and where the element has a particular field value. 
We define a query like this

[source,java]
-----
Query query = pm.newQuery("SELECT FROM mydomain.Supplier " +
    "WHERE this.products.contains(prod) && prod.name == 'Beans' VARIABLES mydomain.Product prod");
-----

So we have a variable in our query called _prod_ that connects the two parts.
You can declare your variables (using the VARIABLES keyword in the single-string form, or via the declareVariables method) 
if you want to define the type like here (*explicit*), or you can leave them for the query compilation to determine (*implicit*).

Another example, in this case our candidate (Product) has no relation, but a class (Inventory) has a relation (1-N) to it (field "products") 
and we want to query based on that relation, returning the product name for a particular inventory.

[source,java]
-----
Query q = pm.newQuery("SELECT this.name FROM mydomain.Product WHERE inv.products.contains(this) AND inv.name == 'Sale' VARIABLES mydomain.Inventory inv");
-----

Note that if declaring multiple variables then they should be semicolon-separated.
See also https://datanucleus.wordpress.com/2015/03/12/jdo-querying-between-classes-without-relation/[this blog post] which demonstrates
variables across 1-1 "relations" where you only have the "id" stored rather than a real relation.


With the Declarative API you would define explicit variables like this
[source,java]
-----
q.variables("mydomain.Product prod");
-----



image:../images/nucleus_extension.png[]

*RDBMS : In all situations we aim for DataNucleus JDOQL implementation to work out the right way of linking a variable into the query, 
whether this is via a join (INNER, LEFT OUTER), or via a subquery. As you can imagine this can be complicated to work out the optimum for all situations
so with that in mind we allow (for a limited number of situations) the option of specifying the join type. This is achieved by setting the query extension 
*datanucleus.query.jdoql.{varName}.join* to the required type. 
For 1-1 relations this would be either "INNERJOIN" or "LEFTOUTERJOIN", and for 1-N relations this would be either "INNERJOIN", "LEFTOUTERJOIN" or "SUBQUERY".

*Please, if you find a situation where the optimum join type is not chosen then report it https://github.com/datanucleus/datanucleus-rdbms[in GitHub] so it can be registered for future work*



[[jdoql_imports]]
== Imports

JDOQL uses the imports declaration to create a type namespace for the query. 
During query compilation, the classes used in the query, if not fully qualified, are searched in this namespace. 
The type namespace is built with primitives types, java.lang.* package, package of the candidate class, import declarations (if any).

To resolve a class, the JDOQL compiler will use the class fully-qualified name to load it, but if the class is not fully qualified, 
it will search by prefixing the class name with the imported package names declared in the type namespace. 
All classes loaded by the query must be acessible by either the candidate class classloader, the PersistenceManager classloader or the current Thread classloader. 
The search algorithm for a class in the JDOQL compiler is the following:

* if the class is fully qualified, load the class.
* if the class is not fully qualified, iterate each package in the type namespace and try to load the class from that package. 
This is done until the class is loaded, or the type namespace package names are exhausted. If the class cannot be loaded an exception is thrown.

Note that the search algorithm can be problematic in performance terms if the class is not fully qualified or declared in imports using package notation. 
To avoid such problems, either use fully qualified class names or import the class in the imports declaration.

NOTE: If you always fully-qualify the candidate, variable and parameter types then there is no need to specify any _imports_ (just like in Java).


[[jdoql_ifelse]]
== IF ELSE expressions

For particular use in the _result_ clause, you can make use of a *IF ELSE* expression where you want to return different things based on some condition(s). 
Like this

[source]
-----
SELECT p.personNum, IF (p.age < 18) 'Youth' ELSE IF (p.age >= 18 && p.age < 65) 'Adult' ELSE 'Old' FROM mydomain.Person p
-----

So in this case the second result value will be a String, either "Youth", "Adult" or "Old" depending on the age of the person.
The BNF structure of the JDOQL IF ELSE expression is

-----
IF (conditional_expression) scalar_expression {ELSE IF (conditional_expression) scalar_expression}* ELSE scalar_expression
-----


[[jdoql_operators]]
== Operators

The following list describes the operator precedence in JDOQL.

* Cast
* Unary ("~") ("!")
* Unary ("+") ("-")
* Multiplicative ("*") ("/") ("%")
* Additive ("+") ("-")
* Relational (">=") (">") ("<=") ("<") ("instanceof")
* Equality ("==") ("!=")
* Boolean logical AND ("&amp;")
* Boolean logical OR ("|")
* DataNucleus Extension : Bitwise AND ("&amp;") - for integral types on PostgreSQL, MySQL, SQLServer, NuoDB
* DataNucleus Extension : Bitwise OR ("|") - for integral types on PostgreSQL, MySQL, SQLServer, NuoDB
* DataNucleus Extension : Bitwise XOR ("^") - for integral types on PostgreSQL, MySQL, SQLServer, NuoDB
* Conditional AND ("&amp;&amp;")
* Conditional OR ("||")

The concatenation operator(+) concatenates a String to either another String or Number. Concatenations of String or Numbers to null results in null.



[[jdoql_instanceof]]
== instanceof

JDOQL allows the Java keyword *instanceof* so you can compare objects against a class.

Let's take an example. We have a class A that has a field "b" of type B and B has subclasses B1, B2, B3. 
Clearly the field "b" of A can be of type B, B1, B2, B3 etc, and we want to find all objects of type A that have the field "b" that is of type B2. We do it like this

[source,java]
-----
Declarative JDOQL :
Query query = pm.newQuery(A.class);
query.setFilter("b instanceof mydomain.B2");
List<A> results = query.executeList();

Single-String JDOQL :
Query query = pm.newQuery("SELECT FROM mydomain.A WHERE b instanceof mydomain.B2");
List results = (List)query.execute();
-----


[[jdoql_casts]]
== casting

JDOQL allows use of Java-style casting so you can type-convert fields etc.

Let's take an example. We have a class A that has a field "b" of type B and B has subclasses B1, B2, B3. 
The B2 subtype has a field "other", and we know that the filtered A will have a B2. 
You could specify a filter using the "B2.other" field like this

[source,java]
-----
((mydomain.B2)b).other == :someVal"
-----


[[jdoql_subqueries]]
== Subqueries

With JDOQL the user has a very flexible query syntax which allows for querying of the vast majority of data components in a single query. 
In some situations it is desirable for the query to utilise the results of a separate query in its calculations. 
JDOQL allows subqueries, so that both calculations can be performed in one query. The syntax of a string-based subquery is as follows

-----
SELECT <subquery-result-clause>
        [FROM <subquery-from-clause>
        [WHERE <filter>]
        [VARIABLES <variable declarations>]
        [PARAMETERS <parameter declarations>]
-----

The _subquery-result-clause_ consists of an optional keyword "DISTINCT" followed by a single expression.
The _subquery-from-clause_ may have one of two forms: A candidate class name followed by an optional alias definition followed by an optional "EXCLUDE SUBCLASSES",
or a field access expression followed by an optional alias definition.

Here's an example, using single-string JDOQL

-----
SELECT FROM mydomain.Employee WHERE salary > (SELECT avg(e.salary) FROM mydomain.Employee e)
-----

So we want to find all Employees that have a salary greater than the average salary.
In single-string JDOQL the subquery must be in parentheses (brackets). Note that we have defined
the subquery with an alias of "e", whereas in the outer query the alias is "this".

We can specify the same query using the Declarative API, like this

[source,java]
-----
Query averageSalaryQuery = pm.newQuery(Employee.class);
averageSalaryQuery.setResult("avg(this.salary)");

Query q = pm.newQuery(Employee.class, "salary > averageSalary");
q.declareVariables("double averageSalary");
q.addSubquery(averageSalaryQuery, "double averageSalary", null, null);
List<Employee> results = q.executeList();
-----

So we define a subquery as its own Query (that could be executed just like any query if so desired),
and the in the main query have an implicit variable that we define as being represented by the subquery.


=== Referring to the outer query in the subquery

JDOQL subqueries allows use of the outer query fields within the subquery if so desired.
Taking the above example and extending it, here is how we do it in single-string JDOQL

[source,java]
-----
SELECT FROM mydomain.Employee WHERE salary > 
    (SELECT avg(e.salary) FROM mydomain.Employee e WHERE e.lastName == this.lastName)
-----

So with single-string JDOQL we make use of the alias identifier "this" to link back to the outer query.

Using the Declarative API, to achieve the same thing we would do

[source,java]
-----
Query averageSalaryQuery = pm.newQuery(Employee.class);
averageSalaryQuery.setResult("avg(this.salary)");
averageSalaryQuery.setFilter("this.lastName == :lastNameParam");

Query q = pm.newQuery(Employee.class, "salary > averageSalary");
q.declareVariables("double averageSalary");
q.addSubquery(averageSalaryQuery, "double averageSalary", null, "this.lastName");
List<Employee> results = q.executeList();
-----

So with the Declarative API we make use of parameters, and the last argument to _addSubquery_ is the value of the parameter _lastNameParam_.


=== Candidate of the subquery being part of the outer query

There are occasions where we want the candidate of the subquery to be part of the outer query, so JDOQL subqueries has the notion of a _candidate expression_.
This is an expression relative to the candidate of the outer query. An example

-----
SELECT FROM mydomain.Employee WHERE this.weeklyhours > 
    (SELECT AVG(e.weeklyhours) FROM this.department.employees e)
-----

so the candidate of the subquery is _this.department.employees_. If using a candidate expression we must provide an alias. 
You can do the same with the Declarative API. Like this

[source,java]
-----
Query averageHoursQuery = pm.newQuery(Employee.class);
averageHoursQuery.setResult("avg(this.weeklyhours)");

Query q = pm.newQuery(Employee.class);
q.setFilter("this.weeklyhours > averageWeeklyhours");
q.addSubquery(averageHoursQuery, "double averageWeeklyhours", "this.department.employees", null);
-----

so now our subquery has a candidate related to the outer query candidate.

*In strict JDOQL you can only have the subquery in the "filter" (WHERE) clause. DataNucleus additionally allows it in the "result" (SELECT) clause.*


=== Using methods on the subquery

A subquery is effectively a Collection, so you have access to the normal methods of a Collection to use on the subquery. Here are a couple of examples

-----
SELECT FROM mydomain.Manager WHERE (SELECT FROM mydomain.Employee e WHERE e.manager == this).isEmpty()
-----

which returns all _Manager_ objects which have no _Employee(s)_.

This can equally be expressed using _contains()_

-----
SELECT FROM mydomain.Manager WHERE !(SELECT FROM mydomain.Employee e).contains(this)
-----


NOTE: There is no _size()_ method on subqueries but you can achieve the same by selecting `COUNT(e)` in the subquery (where `e` is the subquery alias).



[[jdoql_result]]
== Result clause

By default (when not specifying the result) the objects returned will be of the candidate class type, where they match the query filter. 
The _result_ clause can contain (any of) the following


* DISTINCT - optional keyword at the start of the results to make them distinct
* _this_ - the candidate instance
* A field name
* A variable
* A parameter (though why you would want a parameter returning is hard to see since you input the value in the first place)
* An aggregate (count(), avg(), sum(), min(), max())
* An expression involving a field (e.g "field1 + 1")
* A navigational expression (navigating from one field to another ... e.g "field1.field4")

so you could specify something like

-----
count(field1), field2
-----

There are situations when you want to return a single number for a column, representing an aggregate of the values of all records. 
There are 5 standard JDO aggregate functions available. These are

* *avg(val)* - returns the average of "val". "val" can be a field, numeric field expression or "distinct field". Returns double.
* *sum(val)* - returns the sum of "val". "val" can be a field, numeric field expression, or "distinct field". Returns the same type as the type being summed
* *count(val)* - returns the count of records of "val". "val" can be a field, or can be "this", or "distinct field". Returns long
* *min(val)* - returns the minimum of "val". "val" can be a field. Returns the same type as the type used in "min"
* *max(val)* - returns the maximum of "val". "val" can be a field. Returns the same type as the type used in "max"

So to utilise these you could specify a result like

-----
max(price), min(price)
-----

This will return a single row of results with 2 values, the maximum price and the minimum price.

Note that what you specify in the _result_ defines what form of result you get back when executing the query.

* *{ResultClass}* - this is returned if you have only a single row in the results and you specified a result class.
* *Object* - this is returned if you have only a single row in the results and a single column. 
This is achieved when you specified either UNIQUE, or just an aggregate (e.g "max(field2)")
* *Object[]* - this is returned if you have only a single row in the results, but more  than 1 column (e.g "max(field1), avg(field2)")
* *List<{ResultClass}>* - this is returned if you specified a result class.
* *List<Object>* - this is returned if you have only a single column in the result, and you don't have only aggregates in the result (e.g "field2")
* *List<Object[]>* - this is returned if you have more than 1 column in the result, and you don't have only aggregates in the result (e.g "field2, avg(field3)")


With the string-based API the _result_ is part of the query. With the Declarative API you would specify the result like this

[source,java]
-----
q.result(result);

// alternatively q.setResult(result)
-----



[[jdoql_resultclass]]
== Result Class

By default a JDOQL query will return a result matching the result clause. You can override this if you wish by specifying a result class. 
If your query has only a single row in the results then you will get an object of your result class back, otherwise you get a List of result class objects.
The _Result Class_ has to meet certain requirements. These are

* Can be one of Integer, Long, Short, Float, Double, Character, Byte, Boolean, String, java.math.BigInteger, java.math.BigDecimal, 
java.util.Date, java.sql.Date, java.sql.Time, java.sql.Timestamp, java.time.LocalDate, java.time.LocalTime, java.time.LocalDateTime, or Object[]
* Can be a user defined class, that has either a constructor taking arguments of the same type as those returned by the query (in the same order), 
or has a public put(Object, Object) method, or public setXXX() methods, or public fields.

In terms of how the _Result Class_ looks, you have two options

* Constructor taking arguments of the same types and the same order as the result clause. An instance of the result class is created using this constructor. For example
[source,java]
-----
public class Price
{
    protected double amount = 0.0;
    protected String currency = null;

    public Price(double amount, String currency)
    {
        this.amount = amount;
        this.currency = currency;
    }

    ...
}
-----
* Default constructor, and setters for the different result columns, using the alias name for each column as the property name of the setter. For example
[source,java]
-----
public class Price
{
    protected double amount = 0.0;
    protected String currency = null;

    public Price()
    {
    }

    public void setAmount(double amt) {this.amount = amt;}
    public void setCurrency(String curr) {this.currency = curr;}

    ...
}
-----

With the string-based API the _resultClass_ can be part of the query (_INTO {result-class}_). With the Declarative API you would specify the result class upon execution
[source,java]
-----
q.executeResultList(MyResultClass.class);

q.executeResultUnique(MyResultClass.class);
-----



[[jdoql_grouping]]
== Grouping of Results

By default your results will have no specified "grouping". You can specify a _grouping_ to include an optional _having_ expression. 
When grouping is specified, each result expression must either be an expression contained in the grouping, or an aggregate evaluated once per group.


With the string-based API the _grouping_ would be part of the query (_GROUP BY {grouping}_). With the Declarative API you would specify the grouping like this
[source,java]
-----
q.groupBy(grouping);
-----


[[jdoql_ordering]]
== Ordering of Results

By default your results will be returned in the order determined by the datastore, so don't rely on any particular order. 
You can, of course, specify the order yourself. You do this using field/property names and _ASC_/_DESC_ keywords. For example

-----
field1 ASC, field2 DESC
-----

which will sort primarily by _field1_ in ascending order, then secondarily by _field2_ in descending order.

In the ordering you can also define where NULL values of the ordered field/property go in the order, so the full syntax supported is

-----
fieldName [ASC|DESC] [NULLS FIRST|NULLS LAST]
-----

Note that this is only supported for a few RDBMS (H2, HSQLDB, PostgreSQL, DB2, Oracle, Derby, Firebird, SQLServer v11+).


With the string-based API the _ordering_ would be part of the query (_ORDER BY {ordering}_). With the Declarative API you would specify the ordering like this

[source,java]
-----
q.orderBy(ordering);
-----


[[jdoql_range]]
== Range of Results

By default your query will return all results matching the specified filter. You can restrict which results are returned by using the _range_.
For example

-----
RANGE 10,20
-----

which will return just the results numbers 10-19 inclusive. 
Obviously bear in mind that if specifying the range then you should really specify an link:#jdoql_ordering[ordering] otherwise the range positions will be not defined.

With the string-based API the _ordering_ would be part of the query (_RANGE {start,end}_). With the Declarative API you would specify the range like this

[source,java]
-----
q.range(10, 20);
-----

NOTE: _RANGE_ handling is implemented efficiently for MySQL, Postgresql, HSQLDB, H2, SQLServer (using the LIMIT SQL keyword) and Oracle (using the ROWNUM keyword), 
with the query only finding the objects required by the user directly in the datastore. 
For other RDBMS the query will retrieve all objects up to the "to" record, and will not pass any unnecessary objects that are before the "from" record.



[[jdoql_inmemory]]
== JDOQL In-Memory queries

image:../images/nucleus_extension.png[]

The typical use of a JDOQL query is to translate it into the native query language of the datastore and return objects matched by the query. 
Sometimes you want to query over a set of objects that you have to hand, or for some datastores it is simply impossible to support the full JDOQL syntax 
in the datastore _native query language_. In these situation we need to evaluate the query _in-memory_. 
In the latter case of the datastore not supported the full JDOQL syntax we evaluate as much as we can in the datastore and then instantiate 
those objects and evaluate further in-memory. Here we document the current capabilities of _in-memory evaluation_ in DataNucleus.

To enable evaluation in memory you specify the query extension *datanucleus.query.evaluateInMemory* to _true_ as follows

[source,java]
-----
query.addExtension("datanucleus.query.evaluateInMemory","true");
-----

This is also useful where you have a Collection of (persisted) objects and want to run a query over the Collection. 
Simply turn on in-memory evaluation, and supply the candidate collection to the query, and no communication with the datastore will be needed.


WARNING: In-memory JDOQL evaluation does not support variables currently, or correlated subqueries. You should omit such things from your query
and try to evaluate them manually in your own code.



[[jdoql_candidates]]
=== Specify candidates to query over

With JDO you can define a set of candidate objects that should be queried, rather than just going to the datastore to retrieve those objects. 
When you specify this you will automatically be switched to evaluate the query in-memory. You set the candidates like this

[source,java]
-----
Query query = pm.newQuery(...);
query.setCandidates(myCandidates);
List<Product> results = query.executeList();
-----


== Update/Delete queries

JDOQL offers some possibilities for updating/deleting data in the datastore via query.
Note that only the first of these is standard JDOQL, whereas the others are DataNucleus extensions.


[[jdoql_deletebyquery]]
== Deletion by Query

If you want to delete instances of a candidate using a query, you simply define the query candidate/filter in the normal way, 
and then instead of calling _query.executeXXX_ you call _query.deletePersistentAll()_. Like this

[source,java]
-----
Query query = pm.newQuery("SELECT FROM mydomain.A WHERE this.value < 50");
Long number = (Long)query.deletePersistentAll();
-----

The value returned is the number of instances that were deleted. Note that this will perform any cascade deletes that are defined for these instances. 
In addition, all instances in memory will reflect this deletion.



[[jdoql_bulkdelete]]
== Bulk Delete

image:../images/nucleus_extension.png[]

DataNucleus provides an extension to allow bulk deletion. 
This differs from the "Deletion by Query" above in that it simply goes straight to the datastore and performs a bulk delete, leaving it to
the datastore referential integrity to handle relationships. 
To enable "bulk delete" you need the persistence property *datanucleus.query.jdoql.allowAll* set to _true_.
You then perform "bulk delete" like this

[source,java]
-----
Query query = pm.newQuery("DELETE FROM mydomain.A WHERE this.value < 50");
Long number = (Long)query.execute();
-----

Again, the number returned is the number of records deleted.

WARNING: Bulk Delete will not be reflected in L1 cached objects, and cascading defined in metadata will not be invoked when using this


[[jdoql_bulkupdate]]
== Bulk Update

image:../images/nucleus_extension.png[]

DataNucleus provides an extension to allow bulk update. 
This allows you to do bulk updates direct to the datastore without having to load objects into memory etc. 
To enable "bulk update" you need the persistence property *datanucleus.query.jdoql.allowAll* set to _true_.
You then perform "bulk update" like this

[source,java]
-----
Query query = pm.newQuery("UPDATE mydomain.A SET this.value=this.value-5.0 WHERE this.value > 100");
Long number = (Long)query.execute();
-----

Again, the number returned is the number of records updated.

WARNING: Bulk Update will not be reflected in L1 cached objects, and cascading defined in metadata will not be invoked when using this



== JDOQL Strictness

By default DataNucleus allows some extensions in syntax over strict JDOQL (as defined by the JDO spec).
To allow only strict JDOQL you can do as follows

[source,java]
-----
Query query = pm.newQuery(...);
query.addExtension("datanucleus.query.jdoql.strict", "true");
-----


== JDOQL : SQL Generation for RDBMS

When using the method _contains_ on a collection (or _containsKey_, _containsValue_ on a map) this will 
either add an EXISTS subquery (if there is a NOT or OR present in the query) or will add an INNER JOIN across to the element table. Let's take an example

-----
SELECT FROM mydomain.A
WHERE (elements.contains(b1) && b1.name == 'Jones')
VARIABLES mydomain.B b1
-----

Note that we add the _contains_ first that binds the variable "b1" to the element table, and then add the condition on the variable. 
The order is important here. If we instead had put the condition on the variable first we would have had to do a CROSS JOIN to the variable table
and then try to repair the situation and change it to INNER JOIN if possible. In this case the generated SQL will be like

[source,sql]
-----
SELECT `A0`.`ID`
FROM `A` `A0`
INNER JOIN `B` `B0` ON `A0`.ID = `B`.ELEMENT
WHERE `B0`.NAME = 'Jones'
-----

